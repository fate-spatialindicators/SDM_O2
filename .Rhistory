anisotropy = TRUE,
spatial_only = m_df$spatial_only[i]
), silent = TRUE)
if(class(m)!="try-error") {
saveRDS(m, file = paste0("output/wc/model_",i,"_MI.rds"))
}
}
}
back.convert <- function(x, mean_orig, sd_orig) (x* sd_orig+mean_orig)
# Get AIC table
#saveRDS(m_df, "output/wc/models_MI.rds")
#as.list(m$sd_report, "Estimate")$b_threshold
#as.list(m$sd_report, "Std. Error")$b_threshold
# a few plots
# residuals
AICmat <- matrix(NA, nrow = 14, ncol =2)
for (i in 1:nrow(m_df)) {
filename <- paste0("output/wc/model_",i,"_MI.rds")
m <- readRDS(filename)
AICmat[i,1] <-AIC(m)
}
dAIC <- AICmat[,1] - min(AICmat[,1])
dAIC <- matrix(as.numeric(sprintf(dAIC,fmt = '%.2f')), nrow = 14, ncol = 1)
rownames(dAIC) <- c("space + depth + year",
"space + depth + year + temp",
"space + depth + year + o2",
"space + depth + year + p02",
"space + depth + year + mi",
"space + depth + year+temp + o2",
"space + depth + year + temp:o2",
"space + depth + year+temp + po2",
"space + depth + year + temp:po2",
"space + depth + year + o2(breakpoint)",
"space + depth + year + o2(breakpoint) + temp",
"space + depth + year + po2(breakpoint)",
"space + depth + year + po2(breakpoint) + temp",
"space + depth + year + mi(breakpoint)")
dAIC
m_df
source('~/Dropbox/Desktop/Rcode/consonants/code/run_wc_models_MI_v2.R', echo=TRUE)
source('~/Dropbox/Desktop/Rcode/consonants/code/mi_functions.R', echo=TRUE)
m_df <- get_models();
m_df
nrow(m_df)
length(m_df)
get_models <- function() formula <- c("depth + I(depth^2) + as.factor(year)",
"depth + I(depth^2) + as.factor(year) + temp",
"depth + I(depth^2) + as.factor(year) + o2",
"depth + I(depth^2) + as.factor(year) + po2",
"depth + I(depth^2) + as.factor(year) + mi",
"depth + I(depth^2) + as.factor(year) + temp + o2",
"depth + I(depth^2) + as.factor(year) + temp + o2 + temp*o2",
"depth + I(depth^2) + as.factor(year) + temp + po2",
"depth + I(depth^2) + as.factor(year) + temp + po2 + temp * po2",
"depth + I(depth^2) + as.factor(year) + breakpt(o2)",
"depth + I(depth^2) + as.factor(year) + breakpt(o2)+ temp",
"depth + I(depth^2) + as.factor(year) + breakpt(po2)",
"depth + I(depth^2) + as.factor(year) + breakpt(po2) + temp",
"depth + I(depth^2) + as.factor(year) + breakpt(mi)"
)
#devtools::install_github("pbs-assess/sdmTMB")
library(sdmTMB)
library(dplyr)
library(sp)
library(gsw)
library(ggplot2)
dat = readRDS("survey_data/joined_nwfsc_data.rds")
# analyze sablefish for years and hauls with adequate oxygen and temperature data, within range of occurrence
dat = filter(dat, species == "sablefish", year%in%seq(2010,2015),
!is.na(temp), !is.na(o2), !is.na(sal),
latitude_dd > min(latitude_dd[which(cpue_kg_km2>0)]),
latitude_dd <= max(latitude_dd[which(cpue_kg_km2>0)]),
longitude_dd > min(longitude_dd[which(cpue_kg_km2>0)]),
longitude_dd < max(longitude_dd[which(cpue_kg_km2>0)]))
# compute metabolic index (mi) --------------------------------------------
# converted from Halle Berger matlab script
#O2 from trawl data is in ml/l - may need to be converted to umol/kg
gas_const = 8.31
partial_molar_vol = 0.000032
kelvin = 273.15
boltz = 0.000086173324
#calculate percent saturation for O2 - assumes  units of mL O2/L
# Input:       S = Salinity (pss-78)
#              T = Temp (deg C) ! use potential temp
#depth is in meters
#[umole/kg] = [ml/L]*44660/(sigmatheta(P=0,theta,S) + 1000)
dat$SA = gsw_SA_from_SP(dat$sal,dat$depth,dat$longitude_dd,dat$latitude_dd) #absolute salinity for pot T calc
dat$pt = gsw_pt_from_t(dat$SA,dat$temp,dat$depth) #potential temp at a particular depth
dat$CT = gsw_CT_from_t(dat$SA,dat$temp,dat$depth) #conservative temp
dat$sigma0 = gsw_sigma0(dat$SA,dat$CT)
dat$o2_umolkg = dat$o2*44660/(dat$sigma0+1000)
# calc o2 solubility, relies on o2 in umol/kg
gsw_O2sol_SP_pt <- function(sal,pt) {
x = dat$sal
pt68 = dat$pt*1.00024
y = log((298.15 - pt68)/(273.15 + pt68))
a0 =  5.80871
a1 =  3.20291
a2 =  4.17887
a3 =  5.10006
a4 = -9.86643e-2
a5 =  3.80369
b0 = -7.01577e-3
b1 = -7.70028e-3
b2 = -1.13864e-2
b3 = -9.51519e-3
c0 = -2.75915e-7
O2sol = exp(a0 + y*(a1 + y*(a2 + y*(a3 + y*(a4 + a5*y)))) + x*(b0 + y*(b1 + y*(b2 + b3*y)) + c0*x))
return(O2sol)
}
dat$O2_Sat0 = gsw_O2sol_SP_pt(dat$sal,dat$pt)
#= o2satv2a(sal,pt) #uses practical salinity and potential temp - solubity at p =1 atm
dat$press = exp(dat$depth*10000*partial_molar_vol/gas_const/(dat$temp+kelvin))
dat$O2_satdepth = dat$O2_Sat0*dat$press
#solubility at p=0
dat$sol0 = dat$O2_Sat0/0.209
dat$sol_Dep = dat$sol0*dat$press
dat$po2 = dat$o2_umolkg/dat$sol_Dep
# species-specific parameters
Ao = 1.16625e-13
Eo = 0.8736 * 0.5 # from cod, 0.8736.  Make it one half or double
B = 3000 # size in grams, roughly average (initial calculations used 10000g)
n = -0.208 # borrowed from cod
dat$mi = B^n*Ao*dat$po2/exp(-1*Eo/(boltz*(dat$temp+kelvin)))
# prepare data and models -------------------------------------------------
dat <- select(dat, species, year, longitude_dd, latitude_dd, cpue_kg_km2,
o2, temp, depth, mi, po2)
# rescale variables
dat$depth = scale(log(dat$depth))
dat$temp = scale(dat$temp)
mean.po2 <- mean(dat$po2)
std.po2 <- sd(dat$po2)
mean.do <- mean(dat$o2)
std.do <- sd(dat$o2)
mean.mi <- mean(dat$mi)
std.mi <- sd(dat$mi)
dat$mi = scale(dat$mi)
dat$o2 = scale(dat$o2)
dat$po2 <- scale(dat$po2)
# UTM transformation
dat_ll = dat
coordinates(dat_ll) <- c("longitude_dd", "latitude_dd")
proj4string(dat_ll) <- CRS("+proj=longlat +datum=WGS84")
# convert to utm with spTransform
dat_utm = spTransform(dat_ll,
CRS("+proj=utm +zone=10 +datum=WGS84 +units=km"))
# convert back from sp object to data frame
dat = as.data.frame(dat_utm)
dat = dplyr::rename(dat, longitude = longitude_dd,
latitude = latitude_dd)
# run models for each combination of settings/covariates in df ------------
use_cv = FALSE # specify whether to do cross validation or not
spde <- make_spde(x = dat$longitude, y = dat$latitude, n_knots = 250) # choose # knots
m_df <- get_models();
AIC <- dAIC <- tweedie_dens <- matrix(NA, nrow = length(m_df), ncol =1 ) # set up array for tweedie density
rownames(AIC) <- rownames(dAIC) <- rownames(tweedie_dens) <- m_df
AIC
for (i in 1:length(m_df)) {
filename <- paste0("output/wc/model_",i,"_MI.rds")
m <- readRDS(filename)
AICmat[i,1] <-AIC(m)
}
AICmat <- dAIC <- tweedie_dens <- matrix(NA, nrow = length(m_df), ncol =1 ) # set up array for tweedie density
rownames(AICmat) <- rownames(dAIC) <- rownames(tweedie_dens) <- m_df
for (i in 1:length(m_df)) {
filename <- paste0("output/wc/model_",i,"_MI.rds")
m <- readRDS(filename)
AICmat[i,1] <-AIC(m)
}
dAIC <- AICmat[,1] - min(AICmat[,1])
dAIC[,1] <-as.numeric(sprintf(dAIC,fmt = '%.2f'))
dAIC
dAIC[,1] <- AICmat[,1] - min(AICmat[,1])
nrow(dAIC)
AICmat <- dAIC <- tweedie_dens <- matrix(NA, nrow = length(m_df), ncol =1 ) # set up array for tweedie density
rownames(AICmat) <- rownames(dAIC) <- rownames(tweedie_dens) <- m_df
nrow(dAIC)
for (i in 1:length(m_df)) {
filename <- paste0("output/wc/model_",i,"_MI.rds")
m <- readRDS(filename)
AICmat[i,1] <-AIC(m)
}
AICmat
dAIC[,1] <- AICmat[,1] - min(AICmat[,1])
dAIC[,1] <-as.numeric(sprintf(dAIC,fmt = '%.2f'))
dAIC
source('~/Dropbox/Desktop/Rcode/consonants/code/run_wc_models_MI_v2.R', echo=TRUE)
m <- try(sdmTMB(
formula = as.formula(formula),
data = sub,
time = NULL,
reml = TRUE,
spde = spde,
family = tweedie(link = "log"),
anisotropy = TRUE,
spatial_only = TRUE
), silent = TRUE)
sdmTMB(
formula = as.formula(formula),
data = sub,
time = NULL,
reml = TRUE,
spde = spde,
family = tweedie(link = "log"),
anisotropy = TRUE,
spatial_only = TRUE
)
formula
m <- try(sdmTMB(
formula = as.formula(formula),
data = dat,
time = NULL,
reml = TRUE,
spde = spde,
family = tweedie(link = "log"),
anisotropy = TRUE,
spatial_only = TRUE
), silent = TRUE)
source('~/Dropbox/Desktop/Rcode/consonants/code/run_wc_models_MI_v2.R', echo=TRUE)
source('~/Dropbox/Desktop/Rcode/consonants/code/run_wc_models_MI_v2.R', echo=TRUE)
# load handy functions
source("code/mi_functions.R")
# Script to compare fitted Oxygen models
dat <- load_data()
# first load models
m_po2 <- readRDS("output/wc/model_13_MI.rds")
m_o2 <- readRDS("output/wc/model_11_MI.rds")
m_null <- readRDS("output/wc/model_2_MI.rds")
predict_po2 <- predict(m_po2)
predict_o2 <- predict(m_o2)
predict_null <- predict(m_null)
predict_po2$delta <- predict_po2$est - predict_null$est
predict_o2$delta <- predict_o2$est - predict_null$est
library(scales)
ggplot(predict_po2, aes(longitude, latitude, col = delta)) + scale_colour_gradient2() +
geom_point(alpha=0.6) + facet_wrap(~year)
ggplot(predict_o2, aes(longitude, latitude, col = delta)) + scale_colour_gradient2() +
geom_point(alpha=0.6) + facet_wrap(~year)
source('~/Dropbox/Desktop/Rcode/consonants/code/plot_oxygen_prediction.R', echo=TRUE)
bp_po2
slope_po2
bp_po2 * slope_po2
ggplot(predict_po2, aes(longitude, latitude, col = delta)) + scale_colour_gradient2() +
geom_point(alpha=0.6) + facet_wrap(~year) + + labs(fill = "Delta (po2 - null)")
ggplot(predict_po2, aes(longitude, latitude, col = delta)) + scale_colour_gradient2() +
geom_point(alpha=0.6) + facet_wrap(~year) + labs(fill = "Delta (po2 - null)")
ggplot(predict_po2, aes(longitude, latitude, col = delta)) + scale_colour_gradient2() +
geom_point(alpha=0.6) + facet_wrap(~year) + labs(col = "Delta (po2 - null)")
library(scales)
ggplot(predict_po2, aes(longitude, latitude, col = delta)) + scale_colour_gradient2() +
geom_point(alpha=0.6) + facet_wrap(~year) + labs(col = "Delta (po2 - null)")
ggplot(predict_o2, aes(longitude, latitude, col = delta)) + scale_colour_gradient2() +
geom_point(alpha=0.6) + facet_wrap(~year) + labs(col = "Delta (o2 - null)")
# just show the values below the breakpoint
fixed_effects_po2 <- m_po2$model$par
bp_ind <- grep("b_threshold", names(fixed_effects_po2))
bp_po2 <- fixed_effects_po2[bp_ind[2]]
slope_po2 <- fixed_effects_po2[bp_ind[1]]
# create new column in data that contains 0 if po2 is above breakpoint, and lists the actual po2 otherwise
zeros <- rep(0, times = nrow(dat))
dat$po2_bp <- zeros
dat$po2_bp[dat$po2<=bp_po2] = back.convert(dat$po2[dat$po2<=bp_po2], mean.po2, std.po2)
# plot the po2 only below the threshold
ggplot(dat, aes(longitude, latitude, col = po2_bp)) + scale_colour_gradient2() +
geom_point(alpha=0.6) + facet_wrap(~year)
# plot the effect size from po2
above <- rep(exp(bp_po2 * slope_po2), times = nrow(dat))
dat$po2_effect <- above
dat$po2_effect[dat$po2<=bp_po2] = exp((dat$po2[dat$po2<=bp_po2])* slope_po2)
ggplot(dat, aes(longitude, latitude, col = po2_effect)) + scale_colour_gradient2() +
geom_point(alpha=0.6) + facet_wrap(~year)
# create new column in data that contains breakpoint if po2 is above breakpoint, and lists the actual po2 otherwise
zeros <- rep(bp_po2, times = nrow(dat))
dat$po2_bp <- zeros
dat$po2_bp[dat$po2<=bp_po2] = back.convert(dat$po2[dat$po2<=bp_po2], mean.po2, std.po2)
# plot the po2 only below the threshold
ggplot(dat, aes(longitude, latitude, col = po2_bp)) + scale_colour_gradient2() +
geom_point(alpha=0.6) + facet_wrap(~year)
source('~/Dropbox/Desktop/Rcode/consonants/code/plot_oxygen_prediction.R', echo=TRUE)
source('~/Dropbox/Desktop/Rcode/consonants/code/plot_oxygen_prediction.R', echo=TRUE)
ggplot(dat, aes(longitude, latitude, col = log(cpue)) + scale_colour_gradient2() +
ggplot(dat, aes(longitude, latitude, col = log(cpue))) + scale_colour_gradient2() +
geom_point(alpha=0.6) + facet_wrap(~year)
ggplot(dat, aes(longitude, latitude, col = log(cpue_kg_km2 ))) + scale_colour_gradient2() +
geom_point(alpha=0.6) + facet_wrap(~year)
getwd()
knitr::opts_chunk$set(echo = TRUE)
source("code/mi_functions.R")
source("consonants/code/mi_functions.R")
source("code/mi_functions.R")
source("code/mi_functions.R")
functions <- get_models()
functions
source("code/mi_functions.R")
functions <- get_models()
functions
knitr::opts_chunk$set(echo = TRUE)
source("code/mi_functions.R")
source("code/mi_functions.R")
formulas <- get_models()
formulas
use_AIC <- TRUE
m_df <- get_models();
AICmat <- dAIC <- tweedie_dens <- matrix(NA, nrow = length(m_df), ncol =1 ) # set up array for tweedie density
rownames(AICmat) <- rownames(dAIC) <- rownames(tweedie_dens) <- m_df
# Use this if using AIC
if (use_AIC) {
for (i in 1:length(m_df)) {
filename <- paste0("output/wc/model_",i,"_MI.rds")
m <- readRDS(filename)
AICmat[i,1] <-AIC(m)
}
dAIC[,1] <- AICmat[,1] - min(AICmat[,1])
dAIC[,1] <-as.numeric(sprintf(dAIC,fmt = '%.2f'))
dAIC
}
use_AIC <- TRUE
m_df <- get_models();
AICmat <- dAIC <- tweedie_dens <- matrix(NA, nrow = length(m_df), ncol =1 ) # set up array for tweedie density
rownames(AICmat) <- rownames(dAIC) <- rownames(tweedie_dens) <- m_df
# Use this if using AIC
if (use_AIC) {
for (i in 1:length(m_df)) {
filename <- paste0("output/wc/model_",i,"_MI.rds")
m <- readRDS(filename)
AICmat[i,1] <-AIC(m)
}
dAIC[,1] <- AICmat[,1] - min(AICmat[,1])
dAIC[,1] <-as.numeric(sprintf(dAIC,fmt = '%.2f'))
dAIC
}
use_AIC <- TRUE
m_df <- get_models();
AICmat <- dAIC <- tweedie_dens <- matrix(NA, nrow = length(m_df), ncol =1 ) # set up array for tweedie density
rownames(AICmat) <- rownames(dAIC) <- rownames(tweedie_dens) <- m_df
# Use this if using AIC
if (use_AIC) {
for (i in 1:length(m_df)) {
filename <- paste0("output/wc/model_",i,"_MI.rds")
m <- readRDS(filename)
AICmat[i,1] <-AIC(m)
}
dAIC[,1] <- AICmat[,1] - min(AICmat[,1])
dAIC[,1] <-as.numeric(sprintf(dAIC,fmt = '%.2f'))
dAIC
}
use_AIC <- TRUE
m_df <- get_models();
AICmat <- dAIC <- tweedie_dens <- matrix(NA, nrow = length(m_df), ncol =1 ) # set up array for tweedie density
rownames(AICmat) <- rownames(dAIC) <- rownames(tweedie_dens) <- m_df
# Use this if using AIC
if (use_AIC) {
for (i in 1:length(m_df)) {
filename <- paste0("output/wc/model_",i,"_MI.rds")
m <- readRDS(filename)
AICmat[i,1] <-AIC(m)
}
dAIC[,1] <- AICmat[,1] - min(AICmat[,1])
dAIC[,1] <-as.numeric(sprintf(dAIC,fmt = '%.2f'))
dAIC
}
knitr::opts_chunk$set(echo = TRUE)
library(sdmTMB)
library(dplyr)
library(sp)
library(gsw)
library(ggplot2)
knitr::opts_chunk$set(echo = TRUE)
library(sdmTMB)
library(dplyr)
library(sp)
library(gsw)
library(ggplot2)
fixed_effects_po2 <- m_po2$model$par
bp_ind <- grep("b_threshold", names(fixed_effects_po2))
bp_po2 <- fixed_effects_po2[bp_ind[2]]
slope_po2 <- fixed_effects_po2[bp_ind[1]]
# create new column in data that contains breakpoint if po2 is above breakpoint, and lists the actual po2 otherwise
zeros <- rep(bp_po2, times = nrow(dat))
dat$po2_bp <- zeros
dat$po2_bp[dat$po2<=bp_po2] = back.convert(dat$po2[dat$po2<=bp_po2], mean.po2, std.po2)
# plot the po2 only below the threshold
ggplot(dat, aes(longitude, latitude, col = po2_bp)) + scale_colour_gradient2() +
geom_point(alpha=0.6) + facet_wrap(~year) + labs(col = "p02 below breakpoint")
}
fixed_effects_po2 <- m_po2$model$par
bp_ind <- grep("b_threshold", names(fixed_effects_po2))
bp_po2 <- fixed_effects_po2[bp_ind[2]]
slope_po2 <- fixed_effects_po2[bp_ind[1]]
# create new column in data that contains breakpoint if po2 is above breakpoint, and lists the actual po2 otherwise
zeros <- rep(bp_po2, times = nrow(dat))
dat$po2_bp <- zeros
dat$po2_bp[dat$po2<=bp_po2] = back.convert(dat$po2[dat$po2<=bp_po2], mean.po2, std.po2)
# plot the po2 only below the threshold
ggplot(dat, aes(longitude, latitude, col = po2_bp)) + scale_colour_gradient2() +
geom_point(alpha=0.6, size = 0.5) + facet_wrap(~year) + labs(col = "p02 below breakpoint")
}
dat <- load_data()
# rescale variables
dat$depth = scale(log(dat$depth))
dat$temp = scale(dat$temp)
# first load models
m_po2 <- readRDS("output/wc/model_13_MI.rds")
m_o2 <- readRDS("output/wc/model_11_MI.rds")
m_null <- readRDS("output/wc/model_2_MI.rds")
predict_po2 <- predict(m_po2)
predict_o2 <- predict(m_o2)
predict_null <- predict(m_null)
# look at difference in predictions between oxygen models and null
predict_po2$delta <- predict_po2$est - predict_null$est
predict_o2$delta <- predict_o2$est - predict_null$est
library(scales)
ggplot(predict_po2, aes(longitude, latitude, col = delta)) + scale_colour_gradient2() +
geom_point(alpha=0.6) + facet_wrap(~year) + labs(col = "Delta (po2 - null)")
# plot the po2 only below the threshold
ggplot(dat, aes(longitude, latitude, col = log(cpue_kg_km)) + scale_colour_gradient2() +
geom_point(alpha=0.6) + facet_wrap(~year) + labs(col = "p02 below breakpoint")
}
# plot the po2 only below the threshold
ggplot(dat, aes(longitude, latitude, col = log(cpue_kg_km)) + scale_colour_gradient2() +
geom_point(alpha=0.6) + facet_wrap(~year) + labs(col = "p02 below breakpoint")
ggplot(dat, aes(longitude, latitude, col = log(cpue_kg_km2 ))) + scale_colour_gradient2() +
geom_point(alpha=0.6) + facet_wrap(~year)
above <- rep(exp(bp_po2 * slope_po2), times = nrow(dat))
dat$po2_effect <- above
dat$po2_effect[dat$po2<=bp_po2] = exp((dat$po2[dat$po2<=bp_po2])* slope_po2)
ggplot(dat, aes(longitude, latitude, col = po2_effect)) + scale_colour_gradient2() +
geom_point(alpha=0.6) + facet_wrap(~year)
knitr::opts_chunk$set(echo = TRUE)
library(sdmTMB)
library(dplyr)
library(sp)
library(gsw)
library(ggplot2)
dat <- load_data()
knitr::opts_chunk$set(echo = TRUE)
library(sdmTMB)
library(dplyr)
library(sp)
library(gsw)
library(ggplot2)
source("code/mi_functions.R")
formulas <- get_models()
formulas
use_AIC <- TRUE
m_df <- get_models();
AICmat <- dAIC <- tweedie_dens <- matrix(NA, nrow = length(m_df), ncol =1 ) # set up array for tweedie density
rownames(AICmat) <- rownames(dAIC) <- rownames(tweedie_dens) <- m_df
# Use this if using AIC
if (use_AIC) {
for (i in 1:length(m_df)) {
filename <- paste0("output/wc/model_",i,"_MI.rds")
m <- readRDS(filename)
AICmat[i,1] <-AIC(m)
}
dAIC[,1] <- AICmat[,1] - min(AICmat[,1])
dAIC[,1] <-as.numeric(sprintf(dAIC,fmt = '%.2f'))
dAIC
}
dat <- load_data()
plot(dat$po2, dat$o2,
type = "p",
pch = 21,
bg = "black",
xlab = "Partial pressure of oxygen",
ylab = "Dissolved oxygen mg / l"
)
# first load models
m_po2 <- readRDS("output/wc/model_13_MI.rds")
m_o2 <- readRDS("output/wc/model_11_MI.rds")
m_null <- readRDS("output/wc/model_2_MI.rds")
dat <- load_data()
# rescale variables
dat$depth = scale(log(dat$depth))
dat$temp = scale(dat$temp)
dat$depth = scale(log(dat$depth))
dat$temp = scale(dat$temp)
mean.po2 <- mean(dat$po2)
std.po2 <- sd(dat$po2)
mean.do <- mean(dat$o2)
std.do <- sd(dat$o2)
mean.mi <- mean(dat$mi)
std.mi <- sd(dat$mi)
dat$mi = scale(dat$mi)
dat$o2 = scale(dat$o2)
dat$po2 <- scale(dat$po2)
predict_po2 <- predict(m_po2)
predict_o2 <- predict(m_o2)
predict_null <- predict(m_null)
fixed_effects_po2 <- m_po2$model$par
bp_ind <- grep("b_threshold", names(fixed_effects_po2))
bp_po2 <- fixed_effects_po2[bp_ind[2]]
slope_po2 <- fixed_effects_po2[bp_ind[1]]
# create new column in data that contains breakpoint if po2 is above breakpoint, and lists the actual po2 otherwise
zeros <- rep(bp_po2, times = nrow(dat))
dat$po2_bp <- zeros
dat$po2_bp[dat$po2<=bp_po2] = back.convert(dat$po2[dat$po2<=bp_po2], mean.po2, std.po2)
# plot the po2 only below the threshold
ggplot(dat, aes(longitude, latitude, col = po2_bp)) + scale_colour_gradient2() +
geom_point(alpha=0.6, size = 0.5) + facet_wrap(~year) + labs(col = "p02 below breakpoint")
above <- rep(exp(bp_po2 * slope_po2), times = nrow(dat))
dat$po2_effect <- above
dat$po2_effect[dat$po2<=bp_po2] = exp((dat$po2[dat$po2<=bp_po2])* slope_po2)
ggplot(dat, aes(longitude, latitude, col = po2_effect)) + scale_colour_gradient2() +
geom_point(alpha=0.6, scale = 0.5) + facet_wrap(~year)
install.packages(c('repr', 'IRdisplay', 'evaluate', 'crayon', 'pbdZMQ', 'devtools', 'uuid', 'digest'))
devtools::install_github('IRkernel/IRkernel')
IRkernel::installspec() # install for the current user
IRkernel::installspec(user = FALSE) # install system-wide
library(IRkernel)
IRkernel::installspec() # install for the current user
IRkernel::installspec() # install for the current user
